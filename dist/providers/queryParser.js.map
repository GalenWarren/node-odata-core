{"version":3,"sources":["providers/queryParser.js"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;AAQA,IAAM,oBAAoB,SAAI,UAAJ,CAAe,SAAf,CAApB;AACN,IAAM,mBAAmB,SAAI,UAAJ,CAAe,QAAf,CAAnB;;;;;AAKN,IAAM,aAAa,IAAI,GAAJ,CAAQ,iBAAE,GAAF,CAAM,CAC/B,SAD+B,EAE/B,MAF+B,CAAN,EAGxB,UAAC,SAAD,EAAY,KAAZ;SAAsB,CAAE,SAAF,EAAa,KAAb;CAAtB,CAHgB,CAAb;;;AAMN,IAAM,0BAA0B,wCAA1B;;;;;;IAKO;;;;;;AAKX,WALW,WAKX,OAAkC;QAApB,yCAAoB;;0BALvB,aAKuB;;AAChC,SAAK,gBAAL,GAAwB,oBAAoB,uBAApB,CADQ;GAAlC;;;;;;;eALW;;iCAYI;;;UAAP,gBAAO;;;;AAGb,UAAM,eAAe,mBAAoB,IAAI,KAAJ,CAAnC;;;AAHO,aAMN,sBAAE,sBAAO,KAAP,CAAa,YAAb,CAAF,EAA8B,OAA9B;;;;OAIJ,MAJI,CAII,iBAA0B;;;YAAvB,qBAAuB;YAAZ,iBAAY;;AACjC,YAAM,QAAQ,WAAW,GAAX,CAAgB,SAAhB,CAAR,CAD2B;AAEjC,YAAI,iBAAE,WAAF,CAAe,KAAf,CAAJ,EAA4B;AAC1B,gBAAM,IAAI,KAAJ,wCAAgD,SAAhD,CAAN,CAD0B;SAA5B;AAGA,eAAO,KAAP,CALiC;OAA1B;;;AAJJ,OAeJ,MAfI,CAeG,wBAAwD;YAApD,4BAAoD;YAAzC,wCAAyC;;;;YAArB,qBAAqB;YAAX,iBAAW;;;AAE9D,eAAO,iBAAc,SAAd,EAA2B,EAAE,oBAAF,EAAa,gCAAb,EAA8B,YAA9B,EAA3B,CAAP,CAF8D;OAAxD,EAIL;;;AAGD,mBAAW;iBAAW;SAAX;;;AAGX,yBAAiB;iBAAU;SAAV;;OAzBd,CAAP,CANa;;;;;;;;;0CAwCO;AACpB,aAAO,wCAAP,CADoB;;;;;;;;;yCAO+B;UAArC,4BAAqC;UAA1B,wCAA0B;UAAT,oBAAS;;;AAEnD,cAAQ,GAAR,CAAY,KAAZ;;;AAFmD,aAK5C;AACL,mBAAW,SAAX;AACA,yBAAiB,iBAAE,IAAF,CAAQ,eAAR,EAAyB,UAAC,IAAD,EAAO,MAAP,EAAkB;AAC1D,iBAAO,MAAP,CAD0D;SAAlB,CAA1C;OAFF,CALmD;;;;SA3D1C","file":"providers/queryParser.js","sourcesContent":["\nimport parser from \"odata-parser\";\nimport _ from \"lodash\";\n\nimport {Ast} from \"../util/ast\";\nimport {ExpressionParser} from \"./expressionParser\";\n\n// some identifiers\nconst contextIdentifier = Ast.identifier(\"context\");\nconst resultIdentifier = Ast.identifier(\"result\");\n\n/**\n* A map of operations to the order in which they must be performed\n*/\nconst operations = new Map(_.map([\n  \"$filter\",\n  \"$top\"\n], (operation, index) => [ operation, index ]));\n\n// the default expression parser\nconst defaultExpressionParser = new ExpressionParser();\n\n/**\n* A query parser that uses a visitor pattern\n*/\nexport class QueryParser {\n\n  /**\n  * Construction\n  */\n  constructor({ expressionParser }) {\n    this.expressionParser = expressionParser || defaultExpressionParser;\n  }\n\n  /**\n  * Parse the query\n  */\n  parse({ url }) {\n\n    // parse the query portion if there is one\n    const decodedQuery = decodeURIComponent( url.query );\n\n    // generate and return the getResult and transformResult methods\n    return _(parser.parse(decodedQuery)).toPairs()\n\n      // sort the operations in execution order according to the operations\n      // map defined above ...\n      .sortBy( ([ operation, value ]) => {\n        const index = operations.get( operation );\n        if (_.isUndefined( index )) {\n          throw new Error( `Encountered unsupported operation ${operation}`);\n        }\n        return index;\n\n\n      })\n\n      // now, construct\n      .reduce(( { getResult, transformResult }, [operation,value]) => {\n\n        return this[`visit_${operation}`]({ getResult, transformResult, value });\n\n      }, {\n\n        // initial value to get the initial result\n        getResult: context => \"Hello\",\n\n        // the initial value for the transform (identity)\n        transformResult: result => result\n\n      });\n\n  }\n\n  /**\n  * Returns the expression parser to use\n  */\n  getExpressionParser() {\n    return new ExpressionParser();\n  }\n\n  /**\n  * Handle the $filter operation\n  */\n  visit_$filter({ getResult, transformResult, value }) {\n\n    console.log(value);\n\n    // change transformResult to include a filter operation\n    return {\n      getResult: getResult,\n      transformResult: _.wrap( transformResult, (func, result) => {\n        return func();\n      })\n    };\n\n  }\n\n\n}\n"],"sourceRoot":"/source/"}