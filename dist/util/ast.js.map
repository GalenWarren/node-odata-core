{"version":3,"sources":["util/ast.js"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;IAKa;;;;;;;;;;;;qCAKiB;UAAR,iBAAQ;;AAC1B,aAAO;AACL,cAAM,YAAN;AACA,cAAM,IAAN;OAFF,CAD0B;;;;;;;;;mCAUF;UAAT,oBAAS;;AACxB,aAAO;AACL,cAAM,SAAN;AACA,eAAO,KAAP;AACA,kBAAU,MAAM,QAAN,EAAV;OAHF,CADwB;;;;;;;;;;4CAYsB;UAAtB,sBAAsB;UAAd,8BAAc;;;;AAG9C,aAAO;AACL,cAAM,kBAAN;AACA,kBAAU,KAAV;AACA,gBAAQ,MAAR;AACA,kBAAU,IAAI,UAAJ,CAAe;AACvB,gBAAM,UAAN;SADQ,CAAV;OAJF,CAH8C;;;;;;;;;gDAgBV;UAAR,kBAAQ;;;AAEpC,UAAM,QAAQ,KAAK,KAAL,CAAW,GAAX,CAAR,CAF8B;AAGpC,aAAO,sBAAE,KAAF,EAAS,KAAT,CAAe,CAAf,EAAkB,MAAlB,CAA0B,UAAE,IAAF,EAAQ,MAAR,EAAqB;AACpD,eAAO,IAAI,gBAAJ,CAAqB;AAC1B,kBAAQ,MAAR;AACA,sBAAY,IAAZ;SAFK,CAAP,CADoD;OAArB,EAK9B,IAAI,UAAJ,CAAe;AAChB,cAAM,MAAM,CAAN,CAAN;OADC,CALI,CAAP,CAHoC;;;;;;;;;0CAgBE;UAAhB,sBAAgB;UAAR,kBAAQ;;AACtC,aAAO;AACL,cAAM,gBAAN;AACA,gBAAQ,MAAR;AACA,qBAAa,IAAb;OAHF,CADsC;;;;;;;;;2CAWH;UAAZ,0BAAY;;AACnC,aAAO;AACL,cAAM,iBAAN;AACA,kBAAU,QAAV;OAFF,CADmC;;;;;;;;;0CAUL;UAAR,kBAAQ;;AAC9B,aAAO;AACL,cAAM,gBAAN;AACA,cAAM,IAAN;OAFF,CAD8B;;;;;;;;;+CAUmD;UAAtD,kCAAsD;UAAxC,kBAAwC;mCAAlC,WAAkC;UAAlC,8CAAa,sBAAqB;iCAAjB,SAAiB;UAAjB,0CAAW,oBAAM;;AACjF,aAAO;AACL,cAAM,qBAAN;AACA,YAAI,IAAI,UAAJ,CAAe;AACjB,gBAAM,YAAN;SADE,CAAJ;AAGA,gBAAQ,WAAW,GAAX,CAAgB;iBAAQ,IAAI,UAAJ,CAAe;AAC7C,kBAAM,IAAN;WAD8B;SAAR,CAAxB;AAGA,kBAAU,QAAV;AACA,cAAM,IAAN;AACA,mBAAW,KAAX;AACA,oBAAY,KAAZ;OAXF,CADiF;;;;;;;;;mCAmB1D;UAAR,kBAAQ;;AACvB,aAAO;AACL,cAAM,SAAN;AACA,cAAM,IAAN;OAFF,CADuB;;;;SA7Gd","file":"util/ast.js","sourcesContent":["import _ from \"lodash\";\n\n/**\n* Supports ast generation ...\n*/\nexport class Ast {\n\n  /**\n  * Constructs an ast identifier expression\n  */\n  static identifier({ name }) {\n    return {\n      type: \"Identifier\",\n      name: name\n    };\n  }\n\n  /**\n  * Constructs a literal expression\n  */\n  static literal({ value }) {\n    return {\n      type: \"Literal\",\n      value: value,\n      rawValue: value.toString()\n    };\n  }\n\n  /**\n  * Creates an esprima-style object representing member access against\n  * a target\n  */\n  static memberExpression({ target, memberName }) {\n\n    // return the MemberExpression\n    return {\n      type: \"MemberExpression\",\n      computed: false,\n      object: target,\n      property: Ast.identifier({\n        name: memberName\n      })\n    };\n  }\n\n  /**\n  * Creates an expression for a path of property accesses, like a.b.c\n  */\n  static memberPathExpression({ path }) {\n\n    const parts = path.split(\".\");\n    return _(parts).slice(1).reduce( ( part, target  ) => {\n      return Ast.memberExpression({\n        target: target,\n        memberName: part\n      });\n    }, Ast.identifier({\n      name: parts[0]\n    }));\n  }\n\n  /**\n  * Creates a call expression\n  */\n  static callExpression({ callee, args }) {\n    return {\n      type: \"CallExpression\",\n      callee: callee,\n      \"arguments\": args\n    };\n  }\n\n  /**\n  * Creates a return statement\n  */\n  static returnStatement({ argument }) {\n    return {\n      type: \"ReturnStatement\",\n      argument: argument\n    };\n  }\n\n  /**\n  * Creates a block statement for provided body array\n  */\n  static blockStatement({ body }) {\n    return {\n      type: \"BlockStatement\",\n      body: body\n    };\n  }\n\n  /**\n  * Creates a function declaration\n  */\n  static functionDeclaration({ functionName, body, paramNames = [], defaults = [] }) {\n    return {\n      type: \"FunctionDeclaration\",\n      id: Ast.identifier({\n        name: functionName\n      }),\n      params: paramNames.map( name => Ast.identifier({\n        name: name\n      })),\n      defaults: defaults,\n      body: body,\n      generator: false,\n      expression: false\n    };\n  }\n\n  /**\n  * Creates a program node\n  */\n  static program({ body }) {\n    return {\n      type: \"Program\",\n      body: body\n    };\n  }\n\n}\n"],"sourceRoot":"/source/"}